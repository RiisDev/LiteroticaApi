using System.IO.Compression;
using System.Xml.Linq;
using LiteroticaApi.Api;
using LiteroticaApi.DataObjects;
using LiteroticaApi.EpubWriter.Util;
using LiteroticaApi.Util;

namespace LiteroticaApi.EpubWriter
{
	/// <summary>
	/// Represents metadata about a story series, including its title and volume number.
	/// </summary>
	/// <param name="Title">The title of the series.</param>
	/// <param name="Volume">The volume number of the story within the series.</param>
	public record EpubSeries(string Title, int Volume);

	/// <summary>
	/// Represents a story prepared for EPUB generation, containing its metadata and chapters.
	/// </summary>
	/// <param name="Title">The title of the story.</param>
	/// <param name="Language">The language in which the story is written (e.g., "English").</param>
	/// <param name="Author">The author’s name or pseudonym.</param>
	/// <param name="Series">Optional series metadata if the story belongs to one.</param>
	/// <param name="Tags">An array of associated tags or genres describing the story.</param>
	/// <param name="Chapters">A collection of file paths to the chapter text files for the story.</param>
	/// <param name="CoverPath">Optional file path to the story’s cover image.</param>
	public record EpubStory(
		string Title,
		string Language,
		string Author,
		EpubSeries? Series,
		string[] Tags,
		IReadOnlyList<string> Chapters,
		string? CoverPath = null)
	{
		/// <summary>
		/// Gets a unique identifier for this story instance. 
		/// Used internally for metadata consistency and manifest references.
		/// </summary>
		public object Identifier { get; } = Guid.NewGuid();
	}

	/// <summary>
	/// Provides functionality for generating EPUB files from Literotica stories and series.
	/// </summary>
	/// <remarks>
	/// This class uses the Literotica API to fetch story or series data, and then compiles it into
	/// a standards-compliant EPUB structure. It generates all required EPUB components such as
	/// <c>toc.ncx</c>, <c>content.opf</c>, and XHTML files for chapters, cover, and navigation.
	/// </remarks>
	public static class StoryWriter
	{
		private static readonly string TempDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "temp");

		/// <summary>
		/// Represents a method that handles log message events generated by the API or EPUB writer components.
		/// </summary>
		/// <param name="message">
		/// The log message text describing the event, such as progress updates, warnings, or error information.
		/// </param>
		public delegate void OnLogEventHandler(string message);

		/// <summary>
		/// Occurs whenever a log message is emitted by the API, EPUB writer, or internal operations.
		/// </summary>
		/// <remarks>
		/// Subscribe to this event to receive real-time logging output without requiring a console or file logger.
		/// For example:
		/// <code>
		/// StoryWriter.OnLog += message => Console.WriteLine($"[LOG] {message}");
		/// </code>
		/// </remarks>
		public static event OnLogEventHandler? OnLog;

		/// <summary>
		/// Creates an EPUB file from a given <see cref="EpubStory"/> object and outputs it to the specified directory.
		/// </summary>
		/// <param name="story">The <see cref="EpubStory"/> containing metadata, chapters, and optional cover.</param>
		/// <param name="outputDirectory">The directory where the final EPUB file should be saved. Defaults to the base directory.</param>
		/// <param name="raw">If you don't want it to output .epub but instead the raw formatting.</param>
		/// <param name="coverPath">Forcefully set cover art for Epub</param>
		/// <exception cref="Exception">Thrown when a required file cannot be written or an I/O operation fails.</exception>
		public static void CreateEpub(EpubStory story, string? outputDirectory = null, bool raw = false, string coverPath = "")
		{
			string baseDirectory = string.IsNullOrEmpty(outputDirectory)
				? AppDomain.CurrentDomain.BaseDirectory
				: outputDirectory!;
			string storyDirectory = Path.Combine(baseDirectory, UrlUtil.ToSafeFileName(story.Title));

			OnLog?.Invoke("[CreateEpub] Writing EPUB base files...");
			// Extract the default EPUB manifest structure from embedded resources.
			ResourceExtractor.WriteEpubManifest(storyDirectory);

			// Generate core EPUB metadata and navigation files.
			XDocument tocNcx = WriterUtil.GenerateTocNcx(story);
			string tocNcxPath = Path.Combine(storyDirectory, "EPUB", "toc.ncx");
			tocNcx.Save(tocNcxPath);

			XDocument contentOpf = WriterUtil.GenerateContentOpf(story);
			string contentOpfPath = Path.Combine(storyDirectory, "EPUB", "content.opf");
			contentOpf.Save(contentOpfPath);

			XDocument navXhtml = WriterUtil.GenerateNavXhtml(story);
			string navXhtmlPath = Path.Combine(storyDirectory, "EPUB", "nav.xhtml");
			navXhtml.Save(navXhtmlPath);

			// Generate title page.
			XDocument titlePageXhtml = WriterUtil.GenerateTitlePage(story);
			string titlePagePath = Path.Combine(storyDirectory, "EPUB", "text", "title_page.xhtml");
			titlePageXhtml.Save(titlePagePath);

			OnLog?.Invoke("[CreateEpub] Checking for cover art...");
			
			if (!string.IsNullOrEmpty(story.CoverPath) || !string.IsNullOrEmpty(coverPath))
			{
				string coverSourcePath = string.IsNullOrEmpty(coverPath) ? story.CoverPath! : coverPath;
				string coverDestDir = Path.Combine(storyDirectory, "EPUB", "images");
				Directory.CreateDirectory(coverDestDir);
				string coverFileName = "cover" + Path.GetExtension(coverSourcePath);
				string coverDestPath = Path.Combine(coverDestDir, coverFileName);

				if (coverSourcePath.StartsWith("http", StringComparison.OrdinalIgnoreCase))
				{
					try
					{
						using HttpClient httpClient = new ();
						HttpResponseMessage response = httpClient.GetAsync(coverSourcePath).Result;

						if (response.IsSuccessStatusCode)
						{
							using FileStream fileStream = new (
								coverDestPath,
								FileMode.Create,
								FileAccess.Write,
								FileShare.None,
								bufferSize: 8192,
								useAsync: true);

							response.Content.CopyToAsync(fileStream).Wait();
							OnLog?.Invoke($"[CreateEpub] Downloaded cover from URL: {coverSourcePath}");
						}
						else
						{
							OnLog?.Invoke($"[CreateEpub] Failed to download cover (HTTP {response.StatusCode}) from {coverSourcePath}");
							return;
						}
					}
					catch (Exception ex)
					{
						OnLog?.Invoke($"[CreateEpub] Error downloading cover: {ex.Message}");
						return;
					}
				}
				else
				{
					if (!File.Exists(coverSourcePath))
					{
						OnLog?.Invoke("[CreateEpub] CoverArt set, but file not found.");
						return;
					}

					try
					{
						File.Copy(coverSourcePath, coverDestPath, overwrite: true);
						OnLog?.Invoke($"[CreateEpub] Copied cover from {coverSourcePath}");
					}
					catch (Exception ex)
					{
						OnLog?.Invoke($"[CreateEpub] Error copying cover file: {ex.Message}");
						return;
					}
				}

				try
				{
					XDocument coverXhtml = WriterUtil.GenerateCoverPage(story);
					string coverTextDir = Path.Combine(storyDirectory, "EPUB", "text");
					Directory.CreateDirectory(coverTextDir);
					string coverXhtmlPath = Path.Combine(coverTextDir, "cover.xhtml");
					coverXhtml.Save(coverXhtmlPath);
					OnLog?.Invoke($"[CreateEpub] Generated cover.xhtml at {coverXhtmlPath}");
				}
				catch (Exception ex)
				{
					OnLog?.Invoke($"[CreateEpub] Error generating cover.xhtml: {ex.Message}");
				}
			}


			OnLog?.Invoke("[CreateEpub] Writing chapters to file...");
			// Write each chapter file into the EPUB structure.
			for (int i = 0; i < story.Chapters.Count; i++)
			{
				string chapterPathInput = story.Chapters[i];
				string chapterContent = File.ReadAllText(chapterPathInput);

				XDocument chapterDoc = WriterUtil.GenerateChapterXhtml(
					Path.GetFileNameWithoutExtension(chapterPathInput),
					chapterContent,
					i + 1
				);
				
				string chapterOutputPath = Path.Combine(storyDirectory, "EPUB", "text", $"ch{i + 1:000}.xhtml");
				chapterDoc.Save(chapterOutputPath);
				
				OnLog?.Invoke($"[CreateEpub] Writing ch{i + 1:000}.xhtml to file...");

				WriterUtil.CleanChapterFile(chapterOutputPath, OnLog);
			}

			// Package all files into a final EPUB zip archive.);
			string epubFilePath = Path.Combine(baseDirectory, $"{UrlUtil.ToSafeFileName(story.Title)}.epub");
			OnLog?.Invoke($"[CreateEpub] Creating final EPUB file {epubFilePath}");
			if (File.Exists(epubFilePath)) File.Delete(epubFilePath);

			if (raw)
			{
				OnLog?.Invoke("[CreateEpub] Raw output requested, skipping .epub creation.");
				goto Clean;
			}
			ZipFile.CreateFromDirectory(storyDirectory, epubFilePath, CompressionLevel.NoCompression, false);

			OnLog?.Invoke("[CreateEpub] EPUB creation complete, cleaning up.");
			// Clean up temporary working directory.
			Directory.Delete(storyDirectory, true);

			Clean:
			if (!Directory.Exists(TempDir)) return;
			try {Directory.Delete(TempDir, true);} catch{/**/}
		}

		/// <summary>
		/// Generates an EPUB file from an entire series on Literotica, including all its parts (stories).
		/// </summary>
		/// <param name="seriesUrl">The URL of the Literotica series to download and convert.</param>
		/// <param name="outputDirectory">The directory where the EPUB file should be created.</param>
		/// <param name="raw">If you don't want it to output .epub but instead the raw formatting.</param>
		/// <param name="startIndex">What chapter of the series to start at</param>
		/// <param name="endIndex">What chapter of the series to end at</param>
		/// <param name="designatedCover">Forcefully set cover art for Epub</param>
		/// <exception cref="Exception">Thrown if the series cannot be found or has no valid stories.</exception>
		public static async Task CreateEpubFromSeries(string seriesUrl, string outputDirectory, bool raw = false, int startIndex = 0, int endIndex = 2147483647, string designatedCover = "")
		{
			OnLog?.Invoke("[CreateEpubFromSeries] Verifying series url...");
			string seriesSlug = await UrlUtil.GetSeriesId(seriesUrl);

			OnLog?.Invoke("[CreateEpubFromSeries] Fetching series info from api...");
			Series? seriesData = await SeriesApi.GetSeriesInfoAsync(seriesSlug);

			if (seriesData is null || seriesData.Parts.Count == 0 || !seriesData.UserId.HasValue)
				throw new Exception("No stories found in the specified series.");

			Author? author = await AuthorsApi.GetAuthorByIdAsync(seriesData.UserId.Value);

			if (author is null || string.IsNullOrEmpty(author.Username))
				throw new Exception("Failed to fetch author.");

			OnLog?.Invoke($"[CreateEpubFromSeries] Discovered: {seriesData.Title} by {author.Username} with {seriesData.Parts.Count} chapters.");

			OnLog?.Invoke("[CreateEpubFromSeries] Checking for cover art...");
			// Attempt to retrieve the series cover image.
			string? coverPath;
			try
			{
				if (string.IsNullOrEmpty(designatedCover))
				{
					Cover cover = await SeriesApi.GetSeriesCoverAsync(seriesSlug);
					coverPath = cover.Data.Mobile.X1.FilePath;
				}
				else coverPath = designatedCover;
			}
			catch
			{
				coverPath = "";
			}

			OnLog?.Invoke($"[CreateEpubFromSeries] {(string.IsNullOrEmpty(coverPath) ? "Found no cover art." : "Cover art found.")}");

			// Fetch content for each story in the series.
			Dictionary<string, string> chapters = [];

			for (int storyIndex = startIndex; storyIndex < seriesData.Parts.Count; storyIndex++)
			{
				if (storyIndex > endIndex) break;

				Part story = seriesData.Parts[storyIndex];
				OnLog?.Invoke($"[CreateEpubFromSeries] Fetching content: {story.Title}");
				string[] pages = await StoryApi.GetStoryContentAsync(story.Url);
				chapters.Add(story.Title, string.Join(Environment.NewLine + Environment.NewLine, pages));
			}
			
			// Prepare temporary directory for writing chapter files.
			string storyLocation = Path.Combine(TempDir, UrlUtil.ToSafeFileName(seriesData.Title), "Chapters");
			Directory.CreateDirectory(storyLocation);

			OnLog?.Invoke("[CreateEpubFromSeries] Writing chapters to file...");
			foreach (KeyValuePair<string, string> chapter in chapters)
			{
				string chapterFilePath = Path.Combine(storyLocation, $"{UrlUtil.ToSafeFileName(chapter.Key)}.txt");
				File.WriteAllText(chapterFilePath, chapter.Value);
			}

			OnLog?.Invoke("[CreateEpubFromSeries] Generating Epub...");
			// Assemble and create the EPUB.
			EpubStory epubStory = new(
				Title: seriesData.Title,
				Language: "English",
				CoverPath: string.IsNullOrEmpty(designatedCover) ? string.IsNullOrEmpty(coverPath) ? null : coverPath : designatedCover,
				Author: author.Username,
				Series: new EpubSeries(seriesData.Title, 1),
				Tags: [],
				Chapters: Directory.GetFiles(storyLocation)
			);

			CreateEpub(epubStory, outputDirectory, raw, coverPath: designatedCover);
		}

		/// <summary>
		/// Generates an EPUB file from a single Literotica story.
		/// </summary>
		/// <param name="storyUrl">The URL of the story to convert.</param>
		/// <param name="outputDirectory">The directory where the EPUB file should be created.</param>
		/// <param name="raw">If you don't want it to output .epub but instead the raw formatting.</param>
		/// <param name="startIndex">What page to start at.</param>
		/// <param name="endIndex">What chapter of the series to end at</param>
		/// <param name="designatedCover">Forcefully set cover art for Epub</param>
		/// <exception cref="Exception">Thrown if the story or author information cannot be retrieved.</exception>
		public static async Task CreateEpubFromStory(string storyUrl, string outputDirectory, bool raw = false, int startIndex = 1, int endIndex = 2147483647, string designatedCover = "")
		{
			OnLog?.Invoke("[CreateEpubFromStory] Verifying story url...");
			string storySlug = await UrlUtil.GetStorySlug(storyUrl).ConfigureAwait(false);

			OnLog?.Invoke("[CreateEpubFromStory] Fetching story info from api...");
			StoryInfo? storyData = await StoryApi.GetStoryInfoAsync(storySlug);

			if (storyData is null || string.IsNullOrEmpty(storyData.Submission.Authorname))
				throw new Exception("The specified story could not be found or contains no valid content.");

			OnLog?.Invoke("[CreateEpubFromStory] Fetching story content...");

			string[] fullStoryText = await StoryApi.GetStoryContentAsync(storyData.Submission.Url);
			int start = Math.Max(startIndex - 1, 0);
			int end = Math.Min(endIndex, fullStoryText.Length);

			if (start > end)
				throw new Exception("Invalid start or end index for story content.");

			string[] storyText = fullStoryText[start..end];

			// Prepare directory for temporary text file storage.
			string storyLocation = Path.Combine(TempDir, UrlUtil.ToSafeFileName(storyData.Submission.Title), "Chapters");
			Directory.CreateDirectory(storyLocation);

			OnLog?.Invoke("[CreateEpubFromStory] Writing story to file...");
			string chapterFilePath = Path.Combine(storyLocation, $"{UrlUtil.ToSafeFileName(storyData.Submission.Title)}.txt");
			File.WriteAllText(chapterFilePath, string.Join("\n\n", storyText));

			OnLog?.Invoke("[CreateEpubFromStory] Generating Epub...");
			// Construct the EPUB metadata and generate the final file.
			EpubStory epubStory = new(
				Title: storyData.Submission.Title,
				Language: "English",
				CoverPath: string.IsNullOrEmpty(designatedCover) ? null : designatedCover,
				Author: storyData.Submission.Author.Username,
				Series: new EpubSeries(storyData.Submission.Title, 1),
				Tags: storyData.Submission.Tags.Select(tag => tag.TagText.ToString()).ToArray(),
				Chapters: Directory.GetFiles(storyLocation)
			);

			CreateEpub(epubStory, outputDirectory, raw, coverPath: designatedCover);
		}
	}
}
